/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package org.metasploit.framework;

import org.metasploit.simple.Console;

import org.jruby.Ruby;
import org.jruby.RubyNil;
import org.jruby.RubyHash;
import org.jruby.RubyClass;
import org.jruby.RubyString;
import org.jruby.RubyObject;
import org.jruby.RubyException;
import org.jruby.RubyBoolean;
import org.jruby.RubyNoMethodError;

import java.util.Iterator;
import java.util.Map;

/**
 *
 * @author hughneale
 */
public class Exploits extends ModuleManager {

    //private Framework framework;
    //RubyHash exploits;
    //Ruby ruby;

    public Exploits(Framework f) {
        super(f, "exploits");
    }

    public Exploit create(String mod) {

        if (!this.getModule().keySet().contains(mod)) {
            Console.err("Exploit \"" + mod + "\" is not in the database.");
            return null;
        }

        Console.out("Exploit " + mod);

        RubyString exploit_name = RubyString.newString(this.getFramwork().ruby(), mod);

        return new Exploit(this.getFramwork(), (RubyObject) this.getFramwork().invoke(this.getModule(), "create", exploit_name));

        //return new ;

    }

    public Session create(Exploit exp, Payload pay) {
        RubyString payload_name = RubyString.newString(this.getFramwork().ruby(), pay.RefName());
        RubyHash map = RubyHash.newHash(this.getFramwork().ruby());
        map.putAll(exp.getOptions().get());
        RubyHash exploit_options = map;

        RubyHash send = RubyHash.newHash(this.getFramwork().ruby());

        send.put("Payload", payload_name);
        send.put("Options", exploit_options);
        //send.put("OptionStr", "RHOST=10.0.0.1,RPORT=21");
        send.put("LocalInput", (RubyObject) this.getFramwork().scriptlet("Rex::Ui::Text::Input::Stdio.new"));
        send.put("LocalOutput", (RubyObject) this.getFramwork().scriptlet("Rex::Ui::Text::Output::Stdio.new"));
        //send.put("RunAsJob", RubyBoolean.createTrueClass(this.ruby));
        //send.put("Quiet", RubyBoolean.createFalseClass(quick));
        return create_simple(exp, send);
    }

    public Session create(Exploit exp, Options opt) {

        RubyHash send = RubyHash.newHash(this.getFramwork().ruby());
        send.putAll(opt.get());

        return create_simple(exp, send);

    }

    private Session create_simple(Exploit exp, RubyObject... opts) {

        Object oretu = this.getFramwork().invoke(exp.self(), "exploit_simple", opts);

        //Console.pls("\t\tClass Returned " + oretu.getClass().getCanonicalName());

        if (oretu instanceof RubyNil) {
            // RubyNil got nothing :(
            Console.err("Exploit failed.");
            this.error(exp.self());
            return null;
        } else if (oretu instanceof RubyNoMethodError) {
            Console.err("JRuby Failed due to method exception.");
            Console.err(((RubyNoMethodError) oretu).toString());
            return null;
        } else if (oretu instanceof RubyException) {
            Console.err("JRuby Failed due to Ruby Exception.");
            this.getFramwork().exception((RubyObject) oretu);
            return null;
        } else {
            Console.pls("Exploit Succeeded.");
            return new Session(this.getFramwork(), (RubyObject) oretu);
        }
    }
 
}
